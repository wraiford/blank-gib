<div id="web1-page-blog" class="web1-page">

    <article>

        <h1>ibgib blog </h1>

        <section>

            <aside><time class="blog-date" datetime="2025-06-26">June 26, 2025</time></aside>

            <h2>AI-Theming and Ibgib Projects are LIVE <i>(...in early alpha)</i></h2>
            <h3>brief recap</h3>
            <p>For those of you not yet familiar with ibgib, it's a protocol for truly distributed computation. It
                resembles more git than blockchain under the hood, and it perfectly dovetails with the Agentic Era. </p>
            <p>This innovative website in an early alpha stage, utilizing the ibgib protocol throughout its design. In
                short, everything is an ibgib. The agents are ibgibs, the "projects" which we'll get to, the parts of
                the projects, even the "chat" that you see on the right of the screen and even each message within the
                chat...each and every one of these is an ibgib.</p>
            <p>And just as git revolutionized code collaboration, the ibgib protocol completely revolutionizes
                human-agentic collaboration.</p>
            <h3>ibgib.com Update #1: AI-Theming beyond Light/Dark Themes</h3>
            <p>First, the shiny: You can now theme the entire website with natural language via the website's primary
                agent. This isn't just a chatbot and this isn't just a dark theme. We've hooked up the agent with the
                ability to change so many of the website's colors, and we're among the first to do so.</p>
            <p>But that's just a fun thing that others can emulate. The new "projects" capability is our first step to
                ibgib awesomeness. </p>
            <h3>ibgib.com Update #2: Projects have officially begun</h3>
            <p>On the ibgib.com website, we can now create and interact with Agent-backed projects. Now, "project" is
                just a word - a word to help us understand what an ibgib is. Let me explain.</p>
            <p>Every serious project is a complex endeavor that breaks down into sub-projects, with individual
                components that ultimately evolve independently. This trend is especially evident in decoupled hardware
                and software systems, which rely on intricate supply chain networks. So as project scale increases, so
                inevitably does this "sub-project" sprawl. Git's solution to this (and thus almost everyone's solution)
                is either a single monorepo or repo sprawl, each with their pros and cons.
                <button id="monorepo-vs-repo-sprawl-btn" popovertarget="monorepo-vs-repo-sprawl"
                    class="info-popover-btn" aria-label="Show Git Monorepo vs Repo Sprawl Information">üõà</button>
            </p>

            <div id="monorepo-vs-repo-sprawl" class="info-popover" popover>
                <button popovertarget="monorepo-vs-repo-sprawl">‚ùå</button>

                <h3>üõà</h3>
                <h4>git <b>Monorepo</b></h4>
                <p>Pros:</p>
                <ul>
                    <li>Code sharing and reuse are simplified.</li>
                    <li>Dependency management is easier to handle.</li>
                    <li>Atomic changes across multiple components are possible.</li>
                    <li>Code is easier to discover and navigate.</li>
                </ul>
                <p>Cons:</p>
                <ul>
                    <li>Can be slow for large projects due to the size of the repository.</li>
                    <li>Access control can be more complex to manage.</li>
                    <li>Build and test times increase.</li>
                </ul>
                <h4>git <b>Repo Sprawl</b></h4>
                <p>Pros:</p>
                <ul>
                    <li>Faster build and test times due to smaller repository sizes.</li>
                    <li>Simpler access control.</li>
                    <li>Easier to understand the codebase for individual components.</li>
                </ul>
                <p>Cons:</p>
                <ul>
                    <li>Code sharing and reuse are more difficult.</li>
                    <li>Dependency management is more complex.</li>
                    <li>Atomic changes across multiple components are not possible.</li>
                    <li>Code can be harder to discover and navigate.</li>
                </ul>

            </div>

            <h4>Another Way?</h4>
            <aside>
                <p><b>But what if we didn't use git?</b></p>
            </aside>
            <p>What git does NOT allow for is sub-file granularity or cross-repo content-addressing. You can't version a
                function and you can't get a commit hash that points even to a file. So we get tons of small repos with
                a bunch of unnecessary overhead. This is because git's object database (the thing that has the commit
                hashes) does not include repo metadata. This is why you have a .git folder with things like refs, hooks,
                repo description and the config settings proper. None of these are in the object database, so none of
                these can leverage the git push/pull mechanism that makes the source code versioning so useful across
                remotes.</p>
            <p>This is where ibgib and ibgib projects come in.</p>
            <p>A "project" (and a "sub-project") is a friendly wrapper term for an "ibgib". And an ibgib is like a git
                repo but at the semantic level. What does this mean? Git works at the file level of granularity (a
                folder is just a collection of files). But a file is an OS construct and many OS files have tremendous
                semantic structure, i.e., there can be many "things" inside a single file. This is the level that ibgib
                tracks. Each "thing" has a timeline, that looks similar to an entire repo's timeline. Each and every
                piece of semantic data has its own "commit hash" so to speak. When you "change" an ibgib, you actually
                create a new frame on its timeline and link back to the previous address - just like a repo (and a
                blockchain). </p>
            <p>This gives us what I call "supersymmetry". Each piece of data is individually addressed and thus can be
                "imported" into any arbitrary space. This includes metadata and derivative data. So as complexity grows,
                we still use the same timeline dynamics as our foundation. There is no separate code required for a
                package repository. </p>
            <p>Don't get me wrong, there is still inherent complexity as the projects and subprojects grow. But we
                minimize this complexity with a uniform foundation upon which to build and version our software
                artifacts. </p>
            <p>This approach unlocks an entirely new collaboration paradigm just in time for the explosion that is
                accompanying the AI-based agent revolution.</p>
            <h4>check out projects</h4>
            <p>You can explore the beginnings of our project ibgib implementation by navigating to the Projects Tab in
                the left panel and selecting 'New Project'. Then hit the plus sign and you'll be off and going.
                Introduce yourself to your project agent (every ibgib has its own backing agent), and see where it takes
                you.</p>
        </section>

        <section>

            <aside><time class="blog-date" datetime="2025-03-21">March 21, 2025</time></aside>

            <h2>First Funding!</h2>

            <p>

                A momentous day, with the first
                <a href="#/apps/web1/gib/funding.html">funding</a>
                received from a generous individual: $100 !

            </p>

            <p>

                This may or may not have been prompted by the Google workshop I participated in called <a
                    href="https://rsvp.withgoogle.com/events/build-with-ai-aus">Build with AI</a>. It was a fun event
                with a lot of smart, smiling people.

            </p>

            <img src="/images/2025-build-with-ai/early_slide.jpg"
                alt="Shows early on in the workshop with a slide on a projector and some of the other people in the room." />
            <img src="/images/2025-build-with-ai/the_view_1.jpg"
                alt="Shows the view outside of the window, looking out over the river in Austin, TX." />
            <img src="/images/2025-build-with-ai/the_view_2.jpg"
                alt="Shows the view outside of the window, looking down over the sail building adjacent to Google's building where the workshop was held in Austin, TX." />

        </section>


    </article>



</div>
